package launchspec

import (
	"context"
	"errors"
	"fmt"

	"github.com/go-logr/logr"
	eventhandler "github.com/spotinst/ocean-operator/internal/handler"
	"github.com/spotinst/ocean-operator/internal/handler/launchspec"
	"github.com/spotinst/ocean-operator/internal/spot"
	ctrlutil "github.com/spotinst/ocean-operator/internal/util/controller"
	oceanv1 "github.com/spotinst/ocean-operator/pkg/apis/ocean/v1"
	corev1 "k8s.io/api/core/v1"
	apierrors "k8s.io/apimachinery/pkg/api/errors"
	"k8s.io/apimachinery/pkg/types"
	"sigs.k8s.io/controller-runtime/pkg/controller"
	"sigs.k8s.io/controller-runtime/pkg/event"
	"sigs.k8s.io/controller-runtime/pkg/handler"
	logf "sigs.k8s.io/controller-runtime/pkg/log"
	"sigs.k8s.io/controller-runtime/pkg/manager"
	"sigs.k8s.io/controller-runtime/pkg/predicate"
	"sigs.k8s.io/controller-runtime/pkg/reconcile"
	"sigs.k8s.io/controller-runtime/pkg/source"
)

var (
	// controllerName is the name of the controller.
	controllerName = "controller-launchspec"

	// finalizerName is the name of the finalizer.
	finalizerName = fmt.Sprintf("finalizer.%s", oceanv1.SchemeGroupVersion.Group)

	// log is the internal logger used by the controller.
	log = logf.Log.WithName(controllerName)
)

// Add creates a new LaunchSpec Controller and adds it to the Manager. The Manager
// will set fields on the Controller and Start it when the Manager is Started.
func Add(mgr manager.Manager) error {
	return add(mgr, newReconciler(mgr))
}

// newReconciler returns a new handleEvent.ReconcileBase.
func newReconciler(mgr manager.Manager) reconcile.Reconciler {
	return &ReconcileLaunchSpec{
		ReconcileBase: ctrlutil.NewReconcile(
			mgr.GetClient(),
			mgr.GetScheme(),
			mgr.GetEventRecorderFor(controllerName)),
	}
}

// add adds a new Controller to mgr with r as the handleEvent.ReconcileBase.
func add(mgr manager.Manager, r reconcile.Reconciler) error {
	// Create a new controller.
	c, err := controller.New(controllerName, mgr, controller.Options{Reconciler: r})
	if err != nil {
		return err
	}

	// Ignore status-only and metadata-only updates.
	predicates := []predicate.Predicate{
		predicate.GenerationChangedPredicate{},
	}

	// Watch for changes to primary resource LaunchSpec.
	if err = c.Watch(
		&source.Kind{Type: &oceanv1.LaunchSpec{}},
		&handler.EnqueueRequestForObject{},
		predicates...); err != nil {
		return err
	}

	return nil
}

// Blank assignment to verify that ReconcileLaunchSpec implements handleEvent.ReconcileBase.
var _ reconcile.Reconciler = &ReconcileLaunchSpec{}

// ReconcileLaunchSpec reconciles a LaunchSpec object.
type ReconcileLaunchSpec struct {
	ctrlutil.ReconcileBase
}

// ReconcileRequestContext represents a handleEvent request context.
type ReconcileRequestContext struct {
	ctrlutil.RequestContextBase

	// State.
	launchSpecLocal    *oceanv1.LaunchSpec // local state
	launchSpecUpstream *oceanv1.LaunchSpec // upstream state

	// Helpers.
	log     logr.Logger
	handler eventhandler.EventHandler
	ocean   spot.Ocean
}

// Reconcile reads that state of the launchspec for a LaunchSpec object and makes
// changes based on the state read and what is in the LaunchSpec.Spec.
//
// The controller will requeue the Request to be processed again if the returned
// error is non-nil or Result.Requeue is true, otherwise upon completion it will
// remove the work from the queue.
func (r *ReconcileLaunchSpec) Reconcile(req reconcile.Request) (reconcile.Result, error) {
	// Initialize a new request context.
	ctx, err := r.newContext(req)
	if err != nil {
		return ctrlutil.RequeueIfError(err)
	}
	defer ctx.Cancel()

	// Reconcile handlers.
	handlers := []func(*ReconcileRequestContext) error{
		r.handleSync,              // fetch and sync resources
		r.handleFinalizerAddition, // add finalizer on create/update
		r.handleEvent,             // reconcile resources
		r.handleFinalizerRemoval,  // remove finalizer on delete
	}

	// Reconcile.
	for _, fn := range handlers {
		// Process the request and handle any error.
		if err := fn(ctx); err != nil {
			return ctrlutil.RequeueIfError(r.handleCompletion(ctx, err))
		}

		// Should we continue?
		if ctx.Canceled() {
			// The handler signaled us to stop the reconcile by canceling the
			// request context. If we continue here, it will cause two
			// reconciliation loops since a new request was generated by the
			// handler that changed the object (for example, adding or removing
			// a finalizer). To avoid this, we stop this loop, return here and
			// rely on the new request to reconcile the object.
			return ctrlutil.NoRequeue()
		}
	}

	// Done.
	return ctrlutil.RequeueIfError(r.handleCompletion(ctx, nil))
}

func (r *ReconcileLaunchSpec) handleSync(ctx *ReconcileRequestContext) error {
	ctx.log.Info("Handling reconcile sync")

	// Retrieve the local launchspec.
	ctx.log.V(1).Info("Retrieving local launchspec by namespaced name")
	if err := r.GetClient().Get(ctx, ctx.GetRequest().NamespacedName, ctx.launchSpecLocal); err != nil {
		if apierrors.IsNotFound(err) {
			ctx.log.Info("LaunchSpec resource not found; ignoring since object must be deleted")
		}

		return fmt.Errorf("failed to retrieve launchspec resource: %w", err)
	}

	// Retrieve the upstream launchspec.
	if specID := ctx.launchSpecLocal.Status.LaunchSpecID; specID != "" {
		ctx.log.V(1).Info("Retrieving upstream launchspec by ID", "specID", specID)

		c, err := ctx.ocean.GetLaunchSpec(ctx, specID)
		if err != nil {
			return fmt.Errorf("failed to retrieve upstream launchspec: %w", err)
		}

		// Convert back to ocean/v1.LaunchSpec to make our lives easier later.
		ctx.launchSpecUpstream, err = ctx.ocean.NewLaunchSpecConverter().ToObject(c)
		if err != nil {
			return fmt.Errorf("failed to convert upstream launchspec: %w", err)
		}
	}

	return nil
}

func (r *ReconcileLaunchSpec) handleEvent(ctx *ReconcileRequestContext) error {
	ctx.log.Info("Handling reconcile event")

	// Determine event type.
	evt := r.newEvent(ctx)
	if evt == nil { // no action required
		return nil
	}

	// Handle event.
	switch e := evt.(type) {

	// Invoke create handler.
	case event.CreateEvent:
		{
			o, err := ctx.handler.OnCreate(ctx, e)
			if err != nil {
				return err
			}

			ctx.launchSpecUpstream = o.(*oceanv1.LaunchSpec)
			r.RecordEventf(ctx.launchSpecLocal, corev1.EventTypeNormal,
				"SuccessfulCreate", "created launchspec: %v",
				ctx.launchSpecUpstream.Status.LaunchSpecID)

			return nil
		}

	// Invoke update handler.
	case event.UpdateEvent:
		{
			o, err := ctx.handler.OnUpdate(ctx, e)
			if err != nil {
				return err
			}

			ctx.launchSpecUpstream = o.(*oceanv1.LaunchSpec)
			r.RecordEventf(ctx.launchSpecLocal, corev1.EventTypeNormal,
				"SuccessfulUpdate", "updated launchspec: %v",
				ctx.launchSpecUpstream.Status.LaunchSpecID)

			return nil
		}

	// Invoke delete handler.
	case event.DeleteEvent:
		{
			return ctx.handler.OnDelete(ctx, e)
		}

	default:
		return fmt.Errorf("unsupported event type: %v", e)
	}
}

func (r *ReconcileLaunchSpec) handleFinalizerAddition(ctx *ReconcileRequestContext) error {
	hasDeletionTimestamp := ctrlutil.IsBeingDeleted(ctx.launchSpecLocal)
	hasFinalizer := ctrlutil.HasFinalizer(ctx.launchSpecLocal, finalizerName)

	if hasDeletionTimestamp || hasFinalizer {
		return nil
	}

	ctx.log.V(1).Info("Adding finalizer")
	prevGeneration := ctx.launchSpecLocal.GetGeneration()

	ctrlutil.AddFinalizer(ctx.launchSpecLocal, finalizerName)
	if err := r.UpdateResource(ctx, ctx.launchSpecLocal); err != nil {
		return fmt.Errorf("failed to added finalizer: %w", err)
	}

	ctx.log.V(1).Info("Finalizer has been added")
	if prevGeneration != ctx.launchSpecLocal.GetGeneration() {
		// Cancel immediately if the object generation has changed. This prevents
		// some cases where two reconciliation loops will occur.
		ctx.Cancel()
	}

	return nil
}

func (r *ReconcileLaunchSpec) handleFinalizerRemoval(ctx *ReconcileRequestContext) error {
	hasDeletionTimestamp := ctrlutil.IsBeingDeleted(ctx.launchSpecLocal)
	hasFinalizer := ctrlutil.HasFinalizer(ctx.launchSpecLocal, finalizerName)

	if !hasDeletionTimestamp || !hasFinalizer {
		return nil
	}

	ctx.log.V(1).Info("Removing finalizer")
	prevGeneration := ctx.launchSpecLocal.GetGeneration()

	ctrlutil.RemoveFinalizer(ctx.launchSpecLocal, finalizerName)
	if err := r.UpdateResource(ctx, ctx.launchSpecLocal); err != nil {
		return fmt.Errorf("failed to remove finalizer: %w", err)
	}

	ctx.log.V(1).Info("Finalizer has been removed")
	if prevGeneration != ctx.launchSpecLocal.GetGeneration() {
		// Cancel immediately if the object generation has changed. This prevents
		// some cases where two reconciliation loops will occur.
		ctx.Cancel()
	}

	return nil
}

func (r *ReconcileLaunchSpec) handleCompletion(ctx *ReconcileRequestContext, err error) error {
	ctx.log.Info("Handling reconcile completion")

	// Ignore deleted resources and not found errors.
	if ctrlutil.IsBeingDeleted(ctx.launchSpecLocal) ||
		apierrors.IsNotFound(errors.Unwrap(err)) {
		return nil
	}

	// Record a new event in case of failure.
	if err != nil {
		r.RecordEvent(ctx.launchSpecLocal, corev1.EventTypeWarning,
			"FailedReconcile", err.Error())
	}

	// Update the status, if needed.
	if updateErr := r.updateStatus(ctx, err); updateErr != nil {
		return updateErr
	}

	// Return the original error.
	return err
}

func (r *ReconcileLaunchSpec) newContext(req reconcile.Request) (*ReconcileRequestContext, error) {
	// Initialize a new base context.
	ctx := context.Background()

	// Generate a new request ID.
	reqID := ctrlutil.NewRequestId()

	// Initialize a new request logger.
	reqLogger := ctrlutil.NewRequestLogger(log, req, reqID)

	// Initialize a new request context.
	reqCtx := ctrlutil.NewRequestContext(ctx, req, reqID, reqLogger)

	// Initialize a new Spot client.
	spotClient, err := ctrlutil.NewRequestSpotClient(reqCtx, r.GetClient())
	if err != nil {
		return nil, err
	}

	// Initialize a new Ocean service.
	oceanService, err := spotClient.Services().Ocean(spot.CloudProviderAWS)
	if err != nil {
		return nil, err
	}

	// Initialize a new event handler.
	reqHandler := &launchspec.EventHandler{
		Log:   reqLogger,
		Ocean: oceanService,
	}

	// Return a new request context.
	return &ReconcileRequestContext{
		RequestContextBase: reqCtx,
		ocean:              oceanService,
		launchSpecLocal:    new(oceanv1.LaunchSpec),
		log:                reqLogger,
		handler:            reqHandler,
	}, nil
}

func (r *ReconcileLaunchSpec) newEvent(ctx *ReconcileRequestContext) eventhandler.Event {
	m := ctx.launchSpecLocal.GetObjectMeta()
	o := ctx.launchSpecLocal
	u := ctx.launchSpecUpstream

	// Marked for deletion?
	if ctrlutil.IsBeingDeleted(o) {
		return event.DeleteEvent{Meta: m, Object: o}
	}

	// If there is no upstream launchspec, then let's create it.
	if u == nil {
		return event.CreateEvent{Meta: m, Object: o}
	}

	// Compare local and upstream launchspecs.
	if comp := ctrlutil.CompareLaunchSpecSpecs(o.Spec, u.Spec); !comp.Equal {
		return event.UpdateEvent{MetaNew: m, ObjectNew: o}
	}

	return nil
}

func (r *ReconcileLaunchSpec) newCondition(ctx *ReconcileRequestContext, err error) oceanv1.StatusCondition {
	var condition oceanv1.StatusCondition

	if err != nil {
		condition = ctrlutil.NewCondition(
			oceanv1.ConditionTypeReady,
			corev1.ConditionFalse,
			"",
			err.Error())
	} else {
		condition = ctrlutil.NewCondition(
			oceanv1.ConditionTypeReady,
			corev1.ConditionTrue,
			"",
			"")
	}

	return condition
}

func (r *ReconcileLaunchSpec) newStatus(ctx *ReconcileRequestContext, err error) oceanv1.LaunchSpecStatus {
	// Make copies so that we never mutate the shared informer cache.
	launchSpecLocal := ctx.launchSpecLocal.DeepCopy()
	launchSpecUpstream := ctx.launchSpecUpstream.DeepCopy()

	// New status.
	newStatus := oceanv1.LaunchSpecStatus{
		ReconcileStatus: oceanv1.ReconcileStatus{
			ObservedGeneration: launchSpecLocal.Generation,
			Details: oceanv1.StatusDetails{
				ReconcileRequestUID: types.UID(ctx.GetRequestId()),
			},
		},
	}

	// Copy existing conditions one by one so we won't mutate the original object.
	conditions := launchSpecLocal.Status.Conditions
	for i := range conditions {
		newStatus.Conditions = append(newStatus.Conditions, conditions[i])
	}

	// Create or update a Ready condition.
	ctrlutil.AddCondition(&newStatus.ReconcileStatus, r.newCondition(ctx, err))

	// Upstream information.
	if launchSpecUpstream != nil {
		newStatus.LaunchSpecID = launchSpecUpstream.Status.LaunchSpecID
	}

	return newStatus
}

func (r *ReconcileLaunchSpec) updateStatus(ctx *ReconcileRequestContext, err error) error {
	// Make copies so that we never mutate the shared informer cache.
	oldObj := ctx.launchSpecLocal.DeepCopy()
	newObj := ctx.launchSpecLocal.DeepCopy()

	// Build the next status object.
	newObj.Status = r.newStatus(ctx, err)

	// Skip a write if we wouldn't need to update.
	if comp := ctrlutil.CompareLaunchSpecStatuses(oldObj.Status, newObj.Status); !comp.Equal {
		ctx.log.V(1).Info("Updating status", "status", newObj.Status)
		if err := r.UpdateStatus(ctx, newObj); err != nil {
			return err
		}

		ctx.log.V(1).Info("Status has been updated")
	}

	return nil
}
